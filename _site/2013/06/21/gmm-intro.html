<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
<title>Igor-slacker blog
</title>
<meta name="description" content="Igor-slacker blog
">
<meta name="keywords" content="GameMaker, Математика">

<meta property="og:type" content="article">
<meta property="og:title" content="Математика GameMaker - введение &#8211; ">
<meta property="og:description" content="Igor-slacker blog
">
<meta property="og:url" content="http://localhost:4000/2013/06/21/gmm-intro.html">
<meta property="og:site_name" content="">

<!-- Webmaster Tools verfication -->




<link rel="canonical" href="http://localhost:4000/2013/06/21/gmm-intro.html">
<link href="http://localhost:4000/feed.xml" type="application/atom+xml" rel="alternate" title=" Feed">

<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />

<link rel="stylesheet" href=" /css/main.min.css" type="text/css" />
</head>
<body>
  <div class="header-container">
  <header>
      <ul class="nav">
        <!--Change the  URL here if working on an absolute domain-->
        <li><a href="http://localhost:4000"><span class="mega-octicon octicon-terminal" style="margin-right: 6px;"></span>Home</a></li>
        <li><a href="http://localhost:4000/about"><span class="mega-octicon octicon-person" style="margin-right: 6px;"></span>About</a></li>
      </ul>
  </header>
</div>

  <div class="container">
  <h2>Математика GameMaker - введение</h2>
<p class="meta">21 Jun 2013</p>

<div class="post">
<p>Совсем недавно я разбирал парочку занятных вопросов о том, как в GM применяется математика. И столкнулся с занятной проблемой - в том возрасте, когда школьники (без всякого подтекста - просто учащиеся) начинают увлекаться GameMaker, они часто сталкиваются с областями математики, в которую школа их ещё не посвятила. Самообразование - конечно, хорошо, но ему необходимо дать некое направление.</p>

<p>Этот пост внезапно задерживает ближайший урок по языковым конструкциям, потому что язык бесполезен без понимания того, какими данными можно управлять с помощью него. Речь пойдёт, преимущественно, о координатах. А значит, будет некий базовый материал о векторах и немного физики о том, как с их помощью моделировать движение. Зачем всё это надо? Потому что именно таким образом движение смоделировано в GameMaker. И если вы хотите знать, как разместить каждый ваш объект в точности там, где надо, и заставить двигаться, куда надо (при условии, что вы сами этого ещё не знаете) - то вам сюда.</p>

<p>Предварительные требования - выполнение первых двух моих уроков по GML (<a href="http://dside.ru/gml-intro/">вот первый</a>, <a href="http://dside.ru/gml-actions/">вот второй</a>), а также понимание того, как в школе изучается геометрия.</p>

<p>Принципиальных подходов к геометрии я за свою жизнь повидал два. Условно я их называю “классический” и “аналитический”.</p>

<p>Классический - это то, с чего в школах начинают изучать геометрию: что такое точка, прямая, отрезок, треугольник, многоугольник, окружность, круг, разные свойства, виды взаимного расположения; доказательство теорем и решение задач при помощи их применения.</p>

<p>Аналитический - это представление почти всех геометрических понятий и фактов с помощью уравнений и выражений, преобразованиями которых можно многого добиться.</p>

<p>Предполагается, что с азами классического подхода вы уже знакомы, потому что рассказывать я о нём не буду. Почитайте любой учебник по геометрии, если вам так интересно. Я мало встречал учебников, которые могут непонятно объяснять школьную геометрию. Но когда в 10 классе нас начали учить аналитической геометрии, я освоился, проникся и теперь пытаюсь использовать её почаще.</p>

<h3 id="В-чём-мы-работаем">В чём мы работаем</h3>

<p>В “классическом” подходе мы, как правило, используем некое непонятное пространство, которое может содержать геометрические фигуры. Оно может быть плоским (плоское пространство - может звучать, как нонсенс), может быть объёмным. Об этом пространстве мы знаем сравнительно немного. Недостаточно, чтобы смоделировать его в компьютерной программе - нам многое придётся придумывать из ниоткуда.</p>

<p>В аналитической геометрии всё чуть веселее и понятнее. Там мы работаем в некотором “линейном пространстве” (ещё называют “векторным”), элементами которого является то, что мы “в классическим подходе” называем точками. Каждая комната GameMaker - это некое линейное пространство, и любая точка этого пространства - его элемент. У него есть свойства, но пока мы не договоримся, как различать разные элементы пространства, далеко мы не уедем.</p>

<p>Чтобы не блуждать бесцельно и без ориентиров по нашему линейному пространству, придумали системы координат. Это некий элемент линейного пространства, который мы называем нулём, а также набор осей. Поскольку говорить мы собираемся о плоскости, таких осей у нас будет две. Чтобы завести подобную штуку, скажем, у вас в комнате, вам понадобится уже три оси. Ось - это всего лишь известное направление и единица измерения расстояния на ней. Мы здесь будем говорить о комнатах в GameMaker, поэтому сразу “привяжу вас” к тому, что ноль в комнате - это её левый верхний угол, а оси - это направления “вправо” и “вниз”, измеряемые в пикселях.</p>

<h3 id="Вектор">Вектор</h3>

<p>В школах, для простоты понимания, дают определение вектору, как “направленный отрезок”. Раскопаем это определение чуть глубже. Отрезок можно однозначно определить при помощи двух точек - другой отрезок на этих же двух точках невозможен. А его направленность означает только то, что мы можем однозначно сказать об этих двух точках, какая из них первая (начало), а какая вторая (конец).</p>

<p>В некотором смысле, вектором называется лишь то, что находится между двумя точками. Вектор не находится в некотором конкретном месте пространства - это нечто, имеющее известную длину и направление, и всё. Чтобы не париться с тем, что он нигде не находится, считают, что любой вектор можно представить, как находящийся первой точкой в нуле. Вторая точка, в этом случае, однозначно определяет вектор. Что это за точка? Неизвестно, она может быть совершенно любой точкой пространства. Известно то, что если два вектора таким образом попадают в одну и ту же точку - то это (оказывается!) один и тот же вектор. Вторая точка может даже совпадать с первой. В этом случае при размещении первой в нуле, вторая тоже окажется в нуле. Для такого вектора отведено особое понятие “нулевой вектор”, “векторный ноль” или просто “ноль” (стоит обратить внимание, что это не число \(0\), а вот такой \(\vec{0}\)). И раз уж я заговорил об обозначениях - векторы в математике обозначают разнообразными буквами со стрелочкой наверху. Вот так: \(\vec{a}\), \(\vec{b}\), \(\vec{\omega}\) (в общем-то, неважно, из какого алфавита буква, эта из греческого).</p>

<h3 id="Операции">Операции</h3>

<p><img src="http://upload.wikimedia.org/wikipedia/commons/thumb/3/3c/Vecteurs_somme.svg/200px-Vecteurs_somme.svg.png" alt="" /></p>

<p>Сначала научимся складывать векторы. Мы умеем (условно) двигать векторы, не изменяя их (даже не поворачивая - направление также является его характеристикой). Используя это, опишем сложение следующим образом: возьмём один вектор, разместим его первой точкой в нуле. Возьмём второй вектор, и разместим его первой точкой во второй точке первого вектора - тогда его вторая точка попадёт в некую другую точку пространства. Вот вектор, её представляющий, называется суммой наших двух векторов. Нарисовать это можно двумя способами, оба они изображены на картинке рядышком.</p>

<p>Плюс для векторов по свойствам не сильно отличается от своего собрата для чисел. У него следующие свойства:</p>

<ul>
  <li>\(  \vec{a}+\vec{b}=\vec{b}+\vec{a} \)</li>
  <li>\( (\vec{a}+\vec{b})+\vec{c}=\vec{a}+(\vec{b}+\vec{c}) \)</li>
  <li>\(  \vec{a}+\vec{0}=\vec{a}\)</li>
</ul>

<p>Теперь минус. Тут всего пара слов. У любого вектора есть обратный ему вектор. Определяется очень легко: при сложении со своим обратным любой вектор даст ноль. И это не “особенность”, а определение — мы утверждаем, что это за объект и как его получить.</p>

<p>\(\vec{a}+(-\vec{a})=\vec{0}\)</p>

<p>Поразмыслив над правилом суммирования, несложно догадаться, что получить его можно из любого вектора, просто взяв представляющие его точки в обратном порядке.</p>

<p>Имея это в виду, определим вычитание векторов следующим образом:</p>

<p>\(\vec{a}-\vec{b}=\vec{a}+(-\vec{b})\)</p>

<p>Графически - мы уводим первый вектор началом (первой точкой) в ноль, затем сдвигаем второй вектор, чтобы концы (вторые точки) обоих векторов совпали. Тогда вектор разности (результат вычитания) будет представлен началом в нуле, а концом - в начале второго вектора. Нарисуйте это на бумаге, как это нарисовано на картинке выше - пусть это будет упражнением.</p>

<p>Теперь кое-что поинтереснее - вектор можно умножить на число. Простая операция, которую можно описать тремя случаями:</p>

<ul>
  <li>Если умножение на положительное число - то направление не меняется, а длина умножается на число.</li>
  <li>Если умножение на ноль - получается \(\vec{0}\). Нули - они такие.</li>
  <li>Если умножение на отрицательное число - то осознайте смысл вот этой штуки: \(-\vec{a}=-1\cdot\vec{a}\)</li>
</ul>

<h3 id="Координаты">Координаты</h3>

<p>Оси мы уже завели, ноль находится в известном месте. Пора вводить координаты, потому что совсем скоро они нам понадобятся.</p>

<p>Что мы понимаем под осью координат? Выше я уже говорил, что это направление и единица измерения. Отметим, что характеристиками вектора являются его длина и направление. Прямо напрашивается вывод, что каждую ось можно представить вектором. Так и есть - возьмём вектор длиной с одну единицу измерения оси, направленный по ней. <span class="text-muted">Теоретическая справка: набор векторов, представляющих оси координат, называется базисом. Запоминать это вам сейчас не нужно.</span></p>

<p>Базис, который мы будем использовать в GameMaker: это вектор \(\vec{i}\) длиной в 1 пиксель, направленный вправо; и вектор \(\vec{j}\) длиной в 1 пиксель, направленный вниз. Казалось бы - как может стрелочка быть длиной в 1 пиксель? А мы просто не будем понимать её, как стрелочку, это “единица измерения” нашего пространства.</p>

<p>Обратите внимание - в учебном процессе обычно используются графики с вертикальной осью, направленной вверх. Но мы занимаемся больше не теорией, а практикой. У нас оси направлены именно так, и с этим ничего не сделать.</p>

<p>Зачем нам вообще эти векторы? А вот зачем - мы можем получить с их помощью любую точку на экране.
Представьте, что нам нужно получить точку на 50 пикселей правее и на 100 пикселей ниже левого верхнего угла комнаты. Какой вектор представит эта точка? Вот такой:
( \vec{i} \cdot 50 + \vec{j} \cdot 100 )
Числа ( 50 ) и ( 100 ) - и есть координаты. Для удобства, я записываю вектор из координат вот так:
( (50; 100) )
…или даже так, если не хочется путать векторы с точками:
( \overrightarrow{(50; 100)} )
Так повелось, что первой осью считают горизонтальную, а второй - вертикальную. Не будем отступать от этой традиции. GameMaker не отступает, например. Взять, к примеру, функцию <code class="highlighter-rouge">draw_sprite</code>:</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="n">draw_sprite</span><span class="p">(</span><span class="err">спрайт</span><span class="p">,</span> <span class="err">кадр</span><span class="n">_</span><span class="err">спрайта</span><span class="p">,</span> <span class="err">положение</span><span class="n">_</span><span class="err">по</span><span class="n">_x</span><span class="p">,</span> <span class="err">положение</span><span class="n">_</span><span class="err">по</span><span class="n">_y</span><span class="p">);</span></code></pre></figure>

<p>Договорились. С этого момента вектор \( (a; b) \) - то же, что и \( \vec{i} \cdot a + \vec{j} \cdot b \). При этом \(a\) и \(b\) - просто ничем не примечательные числа.
Достаточно очевидно, что длину вектора по координатам можно вычислить такой формулой:
\( l = \sqrt{a^2 + b^2} \)
Формула опирается на теорему Пифагора и тот факт, что \( \vec{i} \) и \( \vec{j} \) направлены под прямым углом (\(90^\circ\)). Формально длину можно определить и иначе, но этих вопросов мы не будем касаться.</p>

<h3 id="Ещё-операции">Ещё операции</h3>

<p>Теперь, когда мы ввели координаты, пришло время обсудить скалярное произведение. Строгого определения этой операции я давать не буду - отмечу лишь, что это операция, делающая из двух векторов некое число. Применять мы будем, как правило, такую:</p>

<table>
  <tbody>
    <tr>
      <td>\( \vec{a} \cdot \vec{b} =</td>
      <td>\vec{a}</td>
      <td>\cdot</td>
      <td>\vec{b}</td>
      <td>\cdot \cos{\widehat{(\vec{a}\vec{b})}} \)</td>
    </tr>
  </tbody>
</table>

<table>
  <tbody>
    <tr>
      <td>\(</td>
      <td>\vec{a}</td>
      <td>\) - длина вектора \(\vec{a}\), а к косинусу мы ещё вернёмся позже. Это определение скалярного произведения называют геометрическим. Однако есть ещё один способ его вычислить, более весёлый и полезный.</td>
    </tr>
  </tbody>
</table>

<p>\( \overrightarrow{(x_1; y_1)} \cdot \overrightarrow{(x_2; y_2)} = x_1 \cdot x_2 + y_1 \cdot y_2 \)</p>

<p>Можете проверить - это работает для любых векторов, и выдаёт точно те же самые значения. Обратите лишь внимание на то, что косинусу нужен угол, измеренный в радианах (\( 180^\circ = \pi \) радиан).</p>

<p>Поскольку эти определения равнозначны - это быстрый способ узнать угол между векторами. Угол может быть лишь от \( 0^\circ \) до \( 180^\circ \), значит, его можно однозначно вычислить при помощи арккосинуса. К работе с углами мы вернёмся позже, поэтому пока на это можно не обращать внимания.</p>

<p>Сложение векторов, представленных координатами (согласно свойствам сложения) выполняется просто путём сложения соответствующих координат. Вот так просто.</p>

<p>\( \overrightarrow{(x_1; y_1)} + \overrightarrow{(x_2; y_2)} = \overrightarrow{(x_1 + x_2; y_1 + y_2)} \)</p>

<p>Умножение вектора на число не сложнее - просто умножить координаты на соответствующее число:</p>

<p>\( \alpha \cdot \overrightarrow{(x; y)} = \overrightarrow{( \alpha \cdot x; \alpha \cdot y)} \)</p>

<p>Вычитание, таким образом, вытекает из двух правил выше.</p>

<p>Координаты в GameMaker повсюду. Надо понимать, как их использовать.</p>

<h3 id="Эксперимент-i">Эксперимент I</h3>

<p>Задание, по большей части, творческое. Побито на этапы:</p>

<ol>
  <li>Используя тот факт, что вид (view) №0 находится в комнате со смещением, указанным в векторе: \(()<code class="highlighter-rouge">view_xview[0]</code>(;)<code class="highlighter-rouge">view_yview[0]</code>()\), перемещайте любой объект так, чтобы он всегда был на 50 пикселей правее и на 100 пикселей ниже левого верхнего угла вида №0.</li>
  <li>Вооружитесь вектором: \((\)<code class="highlighter-rouge">lengthdir_x(расстояние, угол)</code>\(;\)<code class="highlighter-rouge">lengthdir_y(расстояние, угол)</code>\()\), чтобы сделать у курсора мыши стрелочку, всегда указывающую на ( (0; 0) ) (помните о <code class="highlighter-rouge">point_direction</code>!), и отстоящую от курсора на 100 пикселей в том направлении, куда указывает.</li>
  <li>Добавьте вторую стрелочку, указывающую в том же направлении, что и первая, но отстоящую на 100 пикселей против того направления, в котором указывает. В чём подвох? Не пользоваться функциями <code class="highlighter-rouge">lengthdir_x</code>, <code class="highlighter-rouge">lengthdir_y</code>, а также <code class="highlighter-rouge">sin</code> и <code class="highlighter-rouge">cos</code> — только те значения, что были вычислены на предыдущем этапе, их можно.</li>
</ol>

<p>Скалярное произведение и умножение вектора на число на этот раз трогать не будем. В следующем уроке узнаем несколько забавных фактов о том, для чего вообще может быть надо умножать вектор на число, и как так выходит, что при взятии среднего арифметического координат двух точек мы попадаем ровно между ними.</p>

</div>



  

<script type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', '']);
  _gaq.push(['_trackPageview']);
  (function() {
  var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
  ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
  var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();
</script>

  </div><!-- /.main -->
</body>
</html>