<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
<title>Igor-slacker blog
</title>
<meta name="description" content="Igor-slacker blog
">
<meta name="keywords" content="GameMaker, Программирование">

<meta property="og:type" content="article">
<meta property="og:title" content="The Game Maker Language: действия &#8211; ">
<meta property="og:description" content="Igor-slacker blog
">
<meta property="og:url" content="http://localhost:4000/2013/06/10/gml-actions.html">
<meta property="og:site_name" content="">

<!-- Webmaster Tools verfication -->




<link rel="canonical" href="http://localhost:4000/2013/06/10/gml-actions.html">
<link href="http://localhost:4000/feed.xml" type="application/atom+xml" rel="alternate" title=" Feed">

<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />

<link rel="stylesheet" href=" /css/main.min.css" type="text/css" />
</head>
<body>
  <div class="header-container">
  <header>
      <ul class="nav">
        <!--Change the  URL here if working on an absolute domain-->
        <li><a href="http://localhost:4000"><span class="mega-octicon octicon-terminal" style="margin-right: 6px;"></span>Home</a></li>
        <li><a href="http://localhost:4000/about"><span class="mega-octicon octicon-person" style="margin-right: 6px;"></span>About</a></li>
      </ul>
  </header>
</div>

  <div class="container">
  <h2>The Game Maker Language: действия</h2>
<p class="meta">10 Jun 2013</p>

<div class="post">
<p>Надеюсь, с первым уроком вы уже ознакомились. Или уже знакомы с его материалом.</p>

<p>В этом уроке мы обсудим новое понятие в GML, использующее выражения. Называют их по-разному, лично я придерживаюсь перевода “действия”. Поскольку все действия-значки в коде выражаются именно с помощью них.</p>

<p>Справка же даёт иной термин - высказывание (statement).</p>

<p>Вообще, любая программа на GML - это последовательность этих самых “действий”. Любой скрипт и фрагмент кода - это несколько действий, записанных подряд. Лично я пользуюсь синтаксисом стиля С (если не знаете, что это - не обращайте внимания), поэтому действия разделяю между собой знаком <code class="highlighter-rouge">;</code>. Строго говоря, это необязательно. Достаточно каждое действие писать на новой строке. Но если необходимо записать несколько действий в одной - может возникнуть проблема. Давайте придерживаться единых правил, и всё же ставить <code class="highlighter-rouge">;</code>.</p>

<p>Вспомните, что такое “выражение”. Сейчас нам это понадобится.</p>

<h3 id="Присваивания">Присваивания</h3>

<p>Мы уже сталкивались с конструированием выражений и записью их значений в координаты объекта. В прошлом уроке. Если у вас сохранился файл от эксперимента, то скоро сможете устроить своим навыкам небольшую проверку.</p>

<p>Присваиванием называется действие по записи данных в переменную. Данные, как вы знаете - это результат выражений. Поэтому вполне предсказуемо, что формат присваиваний выглядит следующим образом:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>ПЕРЕМЕННАЯ ЗНАК ВЫРАЖЕНИЕ
</code></pre>
</div>

<p>Обсудим каждый из элементов.</p>

<ol>
  <li>
    <p><code class="highlighter-rouge">ПЕРЕМЕННАЯ</code> - просто название переменной. Это может быть как системная, так и ваша собственная. Если она системная, то сверьтесь со справкой - возможно, запись в эту переменную запрещена или бесполезна. А если такой переменной в игре ещё нет (она не системная и вы её не делали), она будет создана! И будет иметь тип доступа “поле”, то есть, будет принадлежать тому и только тому объекту, в котором её записали.
Другие типы видимости переменной необходимо определить до её использования. Чтобы переменная исчезла, как только кончится скрипт, нужно написать подобную конструкцию: <code class="highlighter-rouge">var название;</code>; чтобы переменная стала глобальной, и была единой для всей игры, нужна похожая конструкция: <code class="highlighter-rouge">globalvar название;</code>.</p>
  </li>
  <li>
    <p><code class="highlighter-rouge">ЗНАК</code> - знак присваивания. Обычно это просто <code class="highlighter-rouge">=</code>. С ним значение выражения будет просто записано в переменную, указанную слева. Но есть ряд случаев, когда удобнее использовать и другие. На втором месте после <code class="highlighter-rouge">=</code> по надобности стоит знак <code class="highlighter-rouge">+=</code>. Его проще всего объяснить вот такими двумя абсолютно одинаковыми по эффекту фрагментами: <code class="highlighter-rouge">x = x + 5;</code> и <code class="highlighter-rouge">x += 5;</code></p>
  </li>
  <li>
    <p><code class="highlighter-rouge">ВЫРАЖЕНИЕ</code> - любое корректное выражение, что взбредёт вам в голову. Их мы уже обсуждали в первом уроке, и мне к этому добавить пока нечего. Более сложные выражения мы рассмотрим далее - здесь их тоже можно будет применить.</p>
  </li>
</ol>

<p>Выполняется присваивание просто, как пылесос: вычисляется выражение, а полученное из него значение записывается в переменную по правилу, определённому знаком. Если используется знак <code class="highlighter-rouge">=</code>, то будет записано ровно это самое значение без изменений (а записанное там сейчас просто потеряется). Все прочие знаки присваивания выполняют с текущим значением переменной слева действие, записанное перед знаком <code class="highlighter-rouge">=</code> (если это <code class="highlighter-rouge">+=</code>, выполнится сложение, и так далее), как если бы текущее значение было слева от знака действия, а значение выражения - справа.</p>

<p>Как очень весело накосячить: <code class="highlighter-rouge">x += x + 5;</code>, <code class="highlighter-rouge">x = 5;</code></p>

<p><strong>Пробелы в GML можно расставлять довольно свободно</strong>. Главное - не разделить пробелом название переменной или ключевой знак. <code class="highlighter-rouge">x + 5</code> и <code class="highlighter-rouge">x+5</code> - совершенно равнозначные выражения, и работают одинаково. <em>Что я рекомендую</em>: окружать операторы, вроде <code class="highlighter-rouge">+</code>, пробелами. В длинных выражениях это позволяет лучше разглядеть, что происходит, а также выделить отдельные выражения в круглых скобках <code class="highlighter-rouge">(содержимое)</code>, содержимое которых от самих скобок пробелами отделять не принято. Сложно звучит, вот вам чуть изменённый пример из прошлого урока: <code class="highlighter-rouge">(2 + 2) * 2</code>. Выглядит немножко лучше, чем <code class="highlighter-rouge">(2+2)*2</code>. Неочевидно, почему? Когда у вас возникнет код, в котором операции занимают больше одного символа - думать будет уже поздно.</p>

<p><strong>Присваивание не является выражением!</strong>
Однако, попытка вычислить результат присваивания может привести к осмысленному результату. На самом деле, это всегда будет ноль, за исключением случая, когда используется <code class="highlighter-rouge">=</code>, а значение переменной равно значению выражения. В этом случае значение выражения - <code class="highlighter-rouge">1</code>. Почему так? Догадайтесь.
<strong>Но имейте в виду: присваивание при этом не произойдёт!</strong></p>

<p>Если вы пользуетесь GameMaker: Studio, то в вашем арсенале есть ещё пара причудливых операторов: <code class="highlighter-rouge">++</code> и <code class="highlighter-rouge">--</code>. Почему причудливых? Они работают очень интересно, в зависимости от того, где их написать. Просто написанный возле переменной, оператор <code class="highlighter-rouge">++</code> увеличит её на единицу. Это, по сути, самодостаточное действие. Однако оно является и выражением! Тут уже начинается магия. Предположим, что у нас есть переменные <code class="highlighter-rouge">a</code> и <code class="highlighter-rouge">b</code>, и в них записаны нули.</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="n">a</span> <span class="o">=</span> <span class="n">b</span><span class="o">++</span><span class="p">;</span> <span class="cm">/*b++ сразу вернёт значение b, затем добавит к нему единицу*/</span>
	<span class="cm">/*В "a" окажется ноль. Теперь у нас a=0, b=1*/</span>
<span class="n">a</span> <span class="o">=</span> <span class="o">++</span><span class="n">b</span><span class="p">;</span> <span class="cm">/*Здесь уже наоборот - сначала прибавится единица, и результат будет возвращён уже с ней*/</span>
	<span class="cm">/*В "a" окажется 2.*/</span></code></pre></figure>

<p>Оператор <code class="highlighter-rouge">--</code> работает идентично, но вычитает единицу, а не прибавляет.</p>

<p>Вот, теперь у вас в арсенале есть одно действие, с помощью которых вы можете писать простейшие скрипты. Но написать с этими знаниями полезный скрипт будет тяжеловато. Так что поехали дальше.</p>

<h3 id="Функции">Функции</h3>

<p>Осторожно. Здесь начинается веселье. Вы предупреждены.</p>

<p>Функции - это… некий участок программного кода, который вы можете вызвать. Зачем? А я почём знаю. Но обычно у вызова функции есть четыре возможных причины:</p>

<ol>
  <li>Вам нужен результат функции, который она просто вычисляет</li>
  <li>Вам нужен побочный эффект от выполнения этой функции (скажем, вызвал - и игра выключилась)</li>
  <li>Вам нужен побочный эффект и результат (исполнения требуемого эффекта, например)</li>
  <li>Вам нужен отдых (здесь только доля шутки, позже объясню)</li>
</ol>

<p>У вызова функции есть вполне конкретная структура, но её тяжело описать без особой разметки, свойственной программистам, поэтому приведу несколько примеров, чтобы была понятна суть:</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="err">название</span><span class="n">_</span><span class="err">функции</span><span class="p">(</span><span class="err">выражение</span><span class="p">,</span> <span class="err">ещё</span><span class="n">_</span><span class="err">одно</span><span class="o">+</span><span class="err">выражение</span><span class="p">,</span> <span class="err">ещё</span><span class="o">*</span><span class="err">какое</span><span class="o">-</span><span class="err">нибудь</span><span class="o">/</span><span class="err">выражение</span><span class="p">);</span>
<span class="err">название</span><span class="n">_</span><span class="err">функции</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">"Привет"</span><span class="p">,</span> <span class="mi">3</span><span class="p">.</span><span class="mi">14159</span><span class="p">);</span>
<span class="err">название</span><span class="n">_</span><span class="err">второй</span><span class="n">_</span><span class="err">функции</span><span class="p">();</span></code></pre></figure>

<p>Отметьте - в числах используется <strong>точка</strong> для ограничения дробной части. А использовать плюс для склеивания кусочков текста можно сколько влезет. Сейчас это не очень важно, но заметить стоит.</p>

<p>Где вызов функции - там всегда круглые скобки. Поэтому будем описывать структуру вызова вокруг них. Слева от них находится название функции, которую вы вызываете. Внутри через запятую перечисляются выражения (аргументы функции). Для каждой функции можно прочитать, какие ей нужны аргументы, в каком порядке и зачем. Обычно эту информацию можно найти в справке. Перед вызовом функции эти выражения вычисляются, а полученные значения передаются непосредственно в код функции.</p>

<p>В каком порядке будут вычисляться выражения - доподлинно неизвестно, и рассчитывать на какой-либо конкретный порядок нельзя. Далеко не всегда вычисляться сначала будет самое левое. Известно лишь то, что вычисляться они будут по очереди, не одновременно. В справке на это приведён прекрасный краш-тест, но я сомневаюсь, что вы быстро с этим столкнётесь.</p>

<p>Вызов функции может быть выражением, т. е., её выполнение может оставить после себя значение, прямо как после вычисления выражения. В таких случаях говорят, что “функция возвращает значение”. Скажем, есть функции, которая исключительно вычисляет результат. Синус, например:</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="n">result</span> <span class="o">=</span> <span class="n">sin</span><span class="p">(</span><span class="mi">100</span> <span class="o">/</span> <span class="n">room_speed</span><span class="p">)</span> <span class="o">*</span> <span class="n">radius</span><span class="p">;</span> <span class="o">//</span><span class="err">Написано</span> <span class="err">от</span> <span class="err">балды</span></code></pre></figure>

<p>Но так бывает не всегда. Серьёзно, какая вам разница, с каким результатом завершилось действие “быстро выруби игру”, если игра всё равно завершилась? Она разве что зависнет, если вы ошиблись где-то дальше, но это вы заметите. Однако, это (как любил выражаться мой преподаватель) “паталогический случай”. Большинство функций всё же возвращают какое-то значение.</p>

<p>Наиболее важно то, что <strong>почти все действия в GameMaker выполняются при помощи вызова различных функций</strong>. Нарисовать спрайт? <code class="highlighter-rouge">draw_sprite</code>. Выключить игру? <code class="highlighter-rouge">game_end</code>. Запоминать их все - бесполезно. Они все есть в справке, и для каждой из них строго написано, какие им нужны аргументы и зачем. <em>Если не написано - вас надули, это не функция, а переменная.</em></p>

<p>К сожалению, у некоторых функций весьма необычные аргументы. Поэтому некоторые из них вы не сразу научитесь применять. Можете копать самостоятельно, а можете дождаться следующих уроков, в которых будут покрыты все мыслимые и немыслимые виды аргументов, которые могут требовать разные функции.</p>

<h3 id="Эксперимент-ii">Эксперимент II</h3>

<p>Здесь вам придётся поработать самостоятельно!
<strong>Приготовления:</strong></p>

<ul>
  <li>
    <p><span class="label label-info">Опционально</span> Усовершенствуйте первый урок, используя вместо Jump обычное присваивание в переменные <code class="highlighter-rouge">x</code> и <code class="highlighter-rouge">y</code>.</p>
  </li>
  <li>
    <p>Создайте новый пустой проект с пустой комнатой.</p>
  </li>
  <li>
    <p>Создайте объект, назовите его <code class="highlighter-rouge">obj_spinner</code>.</p>
  </li>
  <li>
    <p>Заставьте <code class="highlighter-rouge">obj_spinner</code> изменять direction при удержании каких-нибудь клавиш.</p>
  </li>
  <li>Выдайте <code class="highlighter-rouge">obj_spinner</code> какой-нибудь спрайт и поставьте его в комнату.
Теперь немножко справочной информации, которую можно всегда подсмотреть в справке, если вам чего-то не хватает:</li>
  <li>Координаты точки, в которой находится мышь: <code class="highlighter-rouge">mouse_x</code> и <code class="highlighter-rouge">mouse_y</code>.</li>
  <li>В GML есть две функции: <code class="highlighter-rouge">lengthdir_x</code> и <code class="highlighter-rouge">lengthdir_y</code>, которые вычисляют координаты точки, в которой окажется объект, если выедет из точки с координатами <code class="highlighter-rouge">(0; 0)</code> на расстояние, указанное в первом аргументе, по курсу, указанному во втором.</li>
  <li>Расстояние указывается в пикселях. Направление - в градусах.</li>
  <li>Направление измеряется от нуля, который указывает вправо, против часовой стрелки. В градусах: 90 это “вверх”, 180 - “влево”, 270 - “вниз”, 360 - опять “вправо”. И 450 - снова “вверх”, и вообще эта штука зациклена.</li>
  <li>Обычно, если функция как-то связана с точкой <code class="highlighter-rouge">(0; 0)</code>, её результат нужно прибавить к точке, которую хотелось бы видеть, как <code class="highlighter-rouge">(0; 0)</code> для этого действия</li>
  <li><code class="highlighter-rouge">image_angle</code> - поле, имеющееся во всех объектах, и в него записывается наклон спрайта в градусах.</li>
  <li><code class="highlighter-rouge">point_direction</code> - функция, которая в четырёх координатах видит две точки и вычисляет направление из первой во вторую. В градусах.</li>
</ul>

<p><strong>А теперь задание:</strong></p>

<ol>
  <li>Заставить <code class="highlighter-rouge">obj_spinner</code> стоять прямо на курсоре мыши.</li>
  <li>Заставить <code class="highlighter-rouge">obj_spinner</code> стоять в 50 пикселях от курсора мыши, причём в стороне, указанной в его <code class="highlighter-rouge">direction</code>. Если там ноль - то справа, если 90, то сверху, и так далее. Чтобы проверить, получилось ли - потыкайте сделанные на приготовлениях клавиши.</li>
  <li>У системной переменной <code class="highlighter-rouge">direction</code> есть собственное назначение, и использовать её для таких действий нехорошо. Избавьтесь от использования встроенной переменной <code class="highlighter-rouge">direction</code>, заменив её на свою собственную переменную. Придумайте ей имя и заботьтесь о ней.</li>
  <li><strong>Задание-бонус:</strong> с помощью <code class="highlighter-rouge">image_angle</code> и вашей новой переменной заставить спрайт у <code class="highlighter-rouge">obj_spinner</code> всегда смотреть на курсор мыши.</li>
  <li><strong>Ещё один бонус:</strong> при помощи <code class="highlighter-rouge">point_direction</code> заставить <code class="highlighter-rouge">obj_spinner</code> всегда смотреть в левый верхний угол комнаты.</li>
</ol>

<p>Как вы понимаете, присылать мне выполненное задание бесполезно, я не стану его проверять. Просить подсказки тоже бесполезно, поскольку выше изложено всё, что вам надо. Если то, что у вас получилось, работает как написано - значит, вы справились.
В первую очередь, успех в выполнении этих экспериментов нужен вам самим, если вы решили изучить GML. Я пишу этот цикл статей лишь в надежде на то, что новички перестанут прилипать с глупыми вопросами вроде “Научишь писать скрипты?”, потому что этим никогда не хотел заниматься ни я сам, ни кто-либо из знакомых мне опытных разработчиков в GameMaker. Равно как не люблю давать сразу готовые решения не самых сложных задач при помощи кода. Пусть попробует сам! Не получилось? Научить искать ошибки.</p>

<blockquote>
  <p><em>Дай человеку рыбу, и ты обеспечишь его едой на один день. Научи его ловить рыбу, и обеспечишь его едой на всю жизнь.</em></p>

  <p>Китайская пословица</p>
</blockquote>

</div>



  

<script type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', '']);
  _gaq.push(['_trackPageview']);
  (function() {
  var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
  ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
  var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();
</script>

  </div><!-- /.main -->
</body>
</html>