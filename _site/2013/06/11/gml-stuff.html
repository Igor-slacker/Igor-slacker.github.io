<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
<title>Igor-slacker blog
</title>
<meta name="description" content="Igor-slacker blog
">
<meta name="keywords" content="GameMaker, Программирование">

<meta property="og:type" content="article">
<meta property="og:title" content="The Game Maker Language: мелочи &#8211; ">
<meta property="og:description" content="Igor-slacker blog
">
<meta property="og:url" content="http://localhost:4000/2013/06/11/gml-stuff.html">
<meta property="og:site_name" content="">

<!-- Webmaster Tools verfication -->




<link rel="canonical" href="http://localhost:4000/2013/06/11/gml-stuff.html">
<link href="http://localhost:4000/feed.xml" type="application/atom+xml" rel="alternate" title=" Feed">

<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />

<link rel="stylesheet" href=" /css/main.min.css" type="text/css" />
</head>
<body>
  <div class="header-container">
  <header>
      <ul class="nav">
        <!--Change the  URL here if working on an absolute domain-->
        <li><a href="http://localhost:4000"><span class="mega-octicon octicon-terminal" style="margin-right: 6px;"></span>Home</a></li>
        <li><a href="http://localhost:4000/about"><span class="mega-octicon octicon-person" style="margin-right: 6px;"></span>About</a></li>
      </ul>
  </header>
</div>

  <div class="container">
  <h2>The Game Maker Language: мелочи</h2>
<p class="meta">11 Jun 2013</p>

<div class="post">
<p>На настоящий момент мы знаем, что такое переменные, умеем присваивать в них данные, умеем вызывать функции. После этого логично рассказать о языковых конструкциях, вроде <code class="highlighter-rouge">if</code>, <code class="highlighter-rouge">while</code>, <code class="highlighter-rouge">with</code>, <code class="highlighter-rouge">for</code> и <code class="highlighter-rouge">switch</code> - но мы споткнёмся об отсутствие данных, которые нам придётся обрабатывать.</p>

<p>Посему, этот урок посвящён некоторым мелочам, которые я упустил в предыдущих уроках, но которые понадобятся нам в следующих. Разговор пойдёт о том, что числами можно выразить не только количество, а также о том, как планировать код, чтобы в нём не запутаться.</p>

<p>Мелочей вышло… много. Каждая языковая конструкция требует некоторого понятия, которое я ещё не трогал. И я пока не хочу швыряться фразами вроде “воспринимайте это, как заклинание”, потому что это сбивает с толку учащихся - от “заклинания” порой тяжело отвыкнуть.</p>

<h3 id="Рекомендации-к-названиям">Рекомендации к названиям</h3>

<p>Откройте справку и просмотрите указатель. Заметьте структуру, согласно которой выстроены почти все названия функций и переменных. Написаны маленькими буквами, латиницей, между словами ставится <code class="highlighter-rouge">_</code>, и слова названия перечисляются, как правило, в порядке раздел_подраздел_действие. Пусть в этом списке не всегда есть подраздел, а иногда встречаются названия из более чем трёх слов - названиями таком формате удобно пользоваться. Чаще всего, роль функции можно узнать, просто переведя её название.</p>

<p>Отметьте также, что в названиях не встречаются цифры. Только рядом с ними. Позже узнаете, как так вышло. Сейчас же отмечу только то, чт любое название не должно начинаться с цифры, иначе всё сломается.</p>

<h3 id="Подтипы">Подтипы</h3>

<p>Фактически, в любой переменной может быть лишь число или фрагмент текста. Но и то, и другое - ерунда, если мы не придаём этим числам и тексту значения. До настоящего момента числа служили нам “мерилом расстояния” в пикселях, с помощью которого мы двигали объекты по комнате, а в прошлом задании нужно было хранить в таких числах углы наклона. Возможно, вы даже успели попользоваться переменными <code class="highlighter-rouge">health</code>, <code class="highlighter-rouge">lives</code> и <code class="highlighter-rouge">score</code> - ведь для них даже создан набор действий-значков, чтобы с ними было легко обращаться. Там числа используются примерно с той же целью - для игрока они означают количество чего-то.</p>

<p>Но технически, числа и слова - всего лишь данные. И ими можно обозначать далеко не только количества и измеримые величины. И, следуя нуждам GML, мы сейчас изучим ряд способов применять числа чуть иначе.</p>

<p>Это не свойство языка, это свойство сознания разработчика придавать числам иной смысл. Различные виды смысла я здесь буду называть подтипами. У них есть одна неприятная особенность - нет никакого способа однозначно определить, к какому подтипу относится число. Единственный способ знать это наверняка - заранее договориться с самим собой о хранении в отдельных переменных значений известного подтипа. Это не так сложно, как кажется. Ведь нет никакой проблемы хранить в одной корзине только красные яблоки, а в другой только зелёные? Нет..? Ладно, сейчас посмотрим.</p>

<h4 id="Логический-подтип">Логический подтип</h4>

<p>С этим всё довольно просто. Выражение логического подтипа является числом, либо <code class="highlighter-rouge">0</code>, либо <code class="highlighter-rouge">1</code>. Причём из-за широкого использования этого подтипа в GML, для него выделены две специальные константы (как переменные, но неизменяемы): <code class="highlighter-rouge">true</code> (истина, при вычислении <code class="highlighter-rouge">1</code>) и <code class="highlighter-rouge">false</code> (ложь, при вычислении <code class="highlighter-rouge">0</code>). Константу можно считать “псевдонимом” для конкретного значения.</p>

<p>На практике критерии обычно слабее - выражение считается ложным лишь в том случае, если оно вычисляется в <code class="highlighter-rouge">0</code>, а иначе истиной. Ходят слухи, что в GameMaker “порог лжи” находится не на нуле, а в районе <code class="highlighter-rouge">0.5</code>, но это не должно вас интересовать. Использование такой неоднозначной природы чисел в программе ещё ни к чему хорошему новичков не приводило.</p>

<p>Для чего это надо? Это нам понадобится, когда мы будем рассматривать языковые конструкции <code class="highlighter-rouge">if</code>, <code class="highlighter-rouge">while</code> и <code class="highlighter-rouge">for</code>. В них мы, среди прочего, задаём выполняющейся программе вопросы, на которые она должна ответить “да” (<code class="highlighter-rouge">true</code>) или “нет” (<code class="highlighter-rouge">false</code>). Вопрос — выражение, результатом которого является 0 или 1, и “по-научному” это называется “логическое выражение”. В серьёзных языках программирования они вычисляются из специальных переменных, которые могут быть только <code class="highlighter-rouge">true</code> или <code class="highlighter-rouge">false</code>, третьего не дано.</p>

<p>Для логического подтипа существует особый набор операций — “логические операторы”. Их можно понять интуитивно, но я опишу формально, чтобы избежать каких-либо вопросов. В описаниях я предполагаю, что <code class="highlighter-rouge">a</code> и <code class="highlighter-rouge">b</code> - любые выражения.</p>

<p>Сначала - как получить выражение логического подтипа из чего-то ещё? Во-первых, такое выражение может быть возвращено функцией (указывается в справке фразами вроде “returns whether…” и “returns true if…”).</p>

<p>Но из мира операций - сюда попадают все операции сравнения: <code class="highlighter-rouge">==</code> (равно), <code class="highlighter-rouge">&lt;</code> (меньше), <code class="highlighter-rouge">&gt;</code> (больше), <code class="highlighter-rouge">&gt;=</code> (больше или равно), <code class="highlighter-rouge">&lt;=</code> (меньше или равно), <code class="highlighter-rouge">!=</code> (не равно).</p>

<p><small class="text-muted"><code class="highlighter-rouge">=</code> тоже сработает в качестве оператора равенства. Но лучше не путаться, где вы его используете для сравнения, а где для присваивания. Используйте <code class="highlighter-rouge">==</code>.
Если у вас это ну никак не укладывается в голове, можно поступить и наоборот - пользоваться присваиванием в стиле Pascal (<code class="highlighter-rouge">a := 2</code>), и использовать <code class="highlighter-rouge">=</code> для сравнения. Поведение и правила никак от этого не изменяются.</small></p>

<ul>
  <li>
    <p>Оператор <code class="highlighter-rouge">&amp;&amp;</code> (применяется, как <code class="highlighter-rouge">a &amp;&amp; b</code>) означает “и”. Он вычисляется в <code class="highlighter-rouge">true</code> лишь в том случае, если <code class="highlighter-rouge">a</code> и <code class="highlighter-rouge">b</code> - не <code class="highlighter-rouge">false</code>. Если хоть одно из выражений <code class="highlighter-rouge">a</code> и <code class="highlighter-rouge">b</code> - <code class="highlighter-rouge">false</code>, то и <code class="highlighter-rouge">a &amp;&amp; b</code> - <code class="highlighter-rouge">false</code>.</p>
  </li>
  <li>
    <p>Аналогично работает оператор <code class="highlighter-rouge">||</code>, но он означает “или”, и вычисляется в истину, если любое из его выражений истинно (или не ложно, что неважно, но лучше правило “только 0 и 1” не нарушать).</p>
  </li>
  <li>
    <p>Операторы <code class="highlighter-rouge">==</code> и <code class="highlighter-rouge">!=</code> прекрасно работают и на логическом подтипе. Это всего лишь числа, в конце концов!</p>
  </li>
  <li>
    <p>Оператор <code class="highlighter-rouge">!</code> (употребляется с одним выражением, как <code class="highlighter-rouge">!a</code>) - слово “не” среди операторов. Выворачивает истинность выражения: если оно было истинным, вернёт ложь, иначе истину.</p>
  </li>
</ul>

<p>Есть смысл сделать “таблицу истинности” для них. Первые два столбца - исходные данные значения переменных <code class="highlighter-rouge">a</code> и <code class="highlighter-rouge">b</code>, а далее выражения с их участием. Каждая строчка — ситуация, когда <code class="highlighter-rouge">a</code> и <code class="highlighter-rouge">b</code> приняли указанные значения, а результаты выражений из первой строчки будут такими:</p>

<table class="table table-condensed table-responsive">
<tr class="success">
	<th>a</th> <th>b</th> <th>a &amp;&amp; b</th> <th>a || b</th> <th>!a</th> <th>!b</th> <th>a == b</th> <th>a != b</th>
</tr>
<tr>
	<td>0</td> <td>0</td> <td>0</td> <td>0</td> <td>1</td> <td>1</td> <td>1</td> <td>0</td>
</tr>
<tr>
	<td>0</td> <td>1</td> <td>0</td> <td>1</td> <td>1</td> <td>0</td> <td>0</td> <td>1</td>
</tr>
<tr>
	<td>1</td> <td>0</td> <td>0</td> <td>1</td> <td>0</td> <td>1</td> <td>0</td> <td>1</td>
</tr>
<tr>
	<td>1</td> <td>1</td> <td>1</td> <td>1</td> <td>0</td> <td>0</td> <td>1</td> <td>0</td>
</tr>
</table>

<p>В качестве примера “зачем это всё надо”, я приведу парочку выражений, и соберу из них большую, практически полезную колбасу.</p>

<p>Предположим, у нас есть аркада-скроллер, где мы долго летаем космическим корабликом. И, скажем, нам необходимо понять, пора ли выпускать на него новые виды противников. Берём переменную, и с самого старта нашего полёта будем засекать, сколько шагов этот будущий кусок металлолома уже летит. Параллельно с этим будем начислять ему очки за каждого сбитого противника.</p>

<p>Пусть у нас в комнате есть некоторый “генератор противников”, которому надо знать, пора ли ему выпускать некий вид противника. А выпускать мы его будем по следующему критерию: игрок должен либо уже долго выживать, либо проявлять большие успехи на поле боя. То есть, у него должен быть некий минимум очков, или же он должен лететь довольно продолжительное время. Скажем, количество шагов в полёте будем записывать в переменную <code class="highlighter-rouge">time</code>, изначально она <code class="highlighter-rouge">0</code>, каждый шаг прибавляем <code class="highlighter-rouge">1</code>.
Запишем условия. Скажем, если за каждого противника начисляется по 10 очков, то если он сбил таких уже полсотни - явно они ему наскучили. С другой стороны, если он не особо активничает, чаще уворачивается, скажем, минуту - пора добавить ему проблем (может, хоть стрелять начнёт?).</p>

<p>Итого. У нас есть условия на score и time.</p>

<ul>
  <li>Не менее, чем по 50 противников по 10 очков: <code class="highlighter-rouge">score &gt;= (10 * 50)</code></li>
  <li>Не менее, чем минута времени: <code class="highlighter-rouge">time &gt;= (room_speed * 60)</code> (где <code class="highlighter-rouge">room_speed</code> - это “шагов в секунду”, системная переменная)</li>
</ul>

<p>Теперь их надо склеить, чтобы любое из условий срабатывало. Оператор <code class="highlighter-rouge">||</code>! Для полной уверенности, что вычисление будет в правильном порядке, обернём выражения в круглые скобки и для наглядности добавим <code class="highlighter-rouge">if</code>.
<code class="highlighter-rouge">if (score &gt;= (10 * 50)) || (time &gt;= (room_speed * 60))</code>
Страшновато выглядит? Можно воспользоваться свободой GML в расстановке переводов строк и пробелов, и записать это дело так:</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="k">if</span> <span class="p">(</span><span class="n">score</span> <span class="o">&gt;=</span> <span class="p">(</span><span class="mi">10</span> <span class="o">*</span> <span class="mi">50</span><span class="p">))</span>
<span class="o">||</span> <span class="p">(</span><span class="n">time</span> <span class="o">&gt;=</span> <span class="p">(</span><span class="n">room_speed</span> <span class="o">*</span> <span class="mi">60</span><span class="p">))</span></code></pre></figure>

<p>Если вас не пугает компактная запись - используйте её. Главное - чтобы вы не запутались в собственном коде. Если вы будете работать в команде с другими программистами, будет уже совсем другая история — нужно будет договориться о том, какой стиль соблюдать при написании: как придумывать названия, как расставлять пробелы и переносы.</p>

<h4 id="Индексный-подтип">Индексный подтип</h4>

<p>Почти все ресурсы игры представлены в GML при помощи индексов. Индекс - это некое целое неотрицательное число (<code class="highlighter-rouge">0</code>, <code class="highlighter-rouge">1</code>, <code class="highlighter-rouge">2</code>…), по которому GM может найти ресурс.</p>

<p>Это такой подтип чисел, значение которого можно исключительно копировать. Изменять значение этого типа как-либо - очень плохая идея, потому что изменив число, вы не сможете по нему найти ресурс, на который оно ссылалось. Для этого числа важен сам факт его существования.</p>

<p><small class="text-muted">Не без исключений, конечно. Вы можете делать с ним разные обратимые вычисления. Если прибавить к индексу 1, а потом вычесть 1 - индекс станет прежним, и по нему вновь можно будет найти указанный ресурс. Но нужно быть достаточно осторожным, чтобы не трогать изменённый индекс, поскольку вы рискуете попасть на совсем другой ресурс (это не так страшно) или вовсе несуществующий (это уже фатально).</small></p>

<p>Также очень плохая идея - пихать индекс одного ресурса в функцию для другого. Это может привести к очень необычным эффектам, поскольку индексы некоторых ресурсов разных видов вполне могут совпадать. К примеру, у <code class="highlighter-rouge">sprite0</code>, <code class="highlighter-rouge">object0</code> и <code class="highlighter-rouge">room0</code>, которые создаются в пустом проекте, индексы наверняка будут одни и те же, но означать каждый из них будет что-то своё, и применять это значение нужно будет соответствующе. Здесь есть где ошибиться. Я даже приведу пример рассуждений, которые видел у кого-то.</p>

<p>Хочется повернуть спрайт у <code class="highlighter-rouge">object1</code>, которому присвоен спрайт <code class="highlighter-rouge">sprite0</code>, что ж, спрайт и повернём: <code class="highlighter-rouge">sprite0.image_angle = 70;</code>
Ожидание: поворот <code class="highlighter-rouge">sprite0</code>, присвоенный <code class="highlighter-rouge">object1</code>.
Реальность: поворачивается спрайт у <code class="highlighter-rouge">object0</code>, который мы вообще не трогали. Как так вышло? Очень просто. <code class="highlighter-rouge">image_angle</code> - это переменная объекта, у спрайтов их просто нет. Операция <code class="highlighter-rouge">.</code> применима только к объектам. И этой строчкой был изменён <code class="highlighter-rouge">image_angle</code> объекта с индексом <code class="highlighter-rouge">0</code> (равному индексу <code class="highlighter-rouge">sprite0</code>). Оказалось, что это <code class="highlighter-rouge">object0</code>, никак, казалось бы, к sprite0 не относящийся. Будьте осторожны с такими моментами.</p>

<p>С этим же связана необходимость никогда не называть различные ресурсы одинаковыми именами. Потому что все названия ресурсов, что вы вводите, можно применять и в коде, и в ваших интересах сделать так, чтобы это было возможно.</p>

<p>Значения переменных индексных подтипов не берутся из ниоткуда. Они есть всего двух видов: в константах и в переменных.
Скорее всего, констант у вас в любом проекте тонна, потому что каждое название спрайта, объекта, комнаты, фона, звука и всего остального - это константа, содержащая соответствующий индекс. Выражение, если угодно. К примеру, у <code class="highlighter-rouge">sprite0</code> (если вы его не переименовывали) значение <code class="highlighter-rouge">0</code>.</p>

<p>Для примера разберём такую строчку: <code class="highlighter-rouge">draw_sprite(sprite0, -1, x, y);</code>. Согласно справке, этой функции требуются, по очереди: индекс спрайта, индекс кадра в спрайте (или -1, чтобы использовать обычную анимацию) и две координаты положения спрайта в комнате. sprite0 - константа, содержащая индекс спрайта (число индексного подтипа). Это не текст <code class="highlighter-rouge">"sprite0"</code>, и попытка подставить именно в таком виде приведёт к проблемам: система не поймёт, какой спрайт ей использовать. А остальные аргументы - самые обычные числа, обозначающие количества или величины. С ними вы уже должны быть в состоянии разобраться сами.</p>

<p>В переменных такие числа могут оказаться двумя способами. Либо вы переписали их из констант, либо создали новые ресурсы при помощи функций - а возвращают такие функции индекс созданного ресурса. К примеру, <code class="highlighter-rouge">sprite_add</code>, если вы хотите загрузить спрайт извне. Конструкция получится вроде: <code class="highlighter-rouge">ваша_переменная = sprite_add(...)</code>.</p>

<p>Различных видов ресурсов - огромное количество, и в дереве ресурсов слева пишутся далеко не все. Сюрфейсы, структуры данных, системы частиц, типы частиц, излучатели… это всё ресурсы, которые могут быть представлены числами-индексами.</p>

<p>Но немножко особняком среди них стоят объекты. Потому что к индексам объектов применима особая операция: <code class="highlighter-rouge">.</code>. Она позволяет обращаться из кода одного объекта к данным другого. Есть ещё одна особенность: на один и тот же объект ссылается несколько индексов сразу. Каждый объект отзывается на свой <code class="highlighter-rouge">id</code> (о них далее), на индекс своего объекта (<code class="highlighter-rouge">object_index</code>), индексы объектов своих родителей (об этом позже) и ключевое слово <code class="highlighter-rouge">all</code> (на которое отзываются вообще все). Как отзываются — расскажу в уроке по языковым конструкциям.</p>

<p>Чаще всего <code class="highlighter-rouge">.</code> применяют к индексам объектов-ресурсов, и очень часто при этом ошибаются. Скажем, если у вас в проекте есть <code class="highlighter-rouge">obj_player</code>, и вы всегда знаете, что он один, то вы можете спокойно обращаться к его переменным, к примеру, вот так: <code class="highlighter-rouge">obj_player.x</code>.
Но будьте аккуратны. Если таких объектов несколько, то чьи именно данные вы получите, точно сказать нельзя. Вы их получите только у одного из объектов этой разновидности. Несколько объектов нужно как-то различать между собой. Способы есть!</p>

<p>Когда нужных вам объектов существует несколько, стоит использовать другой вариант индексного подтипа - индекс экземпляра (instance index). Экземплярами здесь я называю не разновидности объектов, которые вы создаёте в дереве ресурсов, а отдельные “изделия”, которые вы расставляете в комнате или создаёте уже в процессе игры. В каждом объекте он хранится в константе <code class="highlighter-rouge">id</code>. Для чего это может понадобиться, мы узнаем, когда будем рассматривать <code class="highlighter-rouge">with</code>. Нас больше интересует другое: функция instance_create возвращает индекс экземпляра, который она создала.</p>

<p>Вопрос прежний: “нафига нужно”. Предположим, что у нас есть <code class="highlighter-rouge">obj_tank</code> и <code class="highlighter-rouge">obj_turret</code> - танк и его башня (турель, чтобы был понятен перевод). И логично, что у каждого танка должна быть своя башня, и они не должны их путать между собой. Выход прост - размещать будем только сами танки, без башен - а башни будем создавать тогда, когда создаётся танк. При создании танка создадим на нём же его башню, и запишем её к себе в переменную-поле (поле у каждого экземпляра будет своё, помните?): <code class="highlighter-rouge">my_turret = instance_create(x, y, obj_turret);</code>. Тогда в коде нашего танка можно легко менять направление <strong>только его собственной</strong> турели: <code class="highlighter-rouge">my_turret.image_angle = 60;</code>. Другие турели этот код не тронет. Вообще этот приём чрезвычайно полезен, и о нём я расскажу в одном из последних уроков, где мы будем говорить о чуть более абстрактных вещах, чем написание скриптов - о планировании игры и взаимодействии между объектами. Той самой “чёрной магии”, о которой я говорил в самом первом посте.</p>

<p>Есть и другие способы достать индексы отдельных экземпляров. Можно это делать функциями <code class="highlighter-rouge">instance_nearest</code> и <code class="highlighter-rouge">instance_furthest</code> - которые особенно полезны для выбора цели обстрела. Как можно предположить из названия, эти функции просматривают все указанные им объекты, и возвращают тот, который ближе всего (или дальше, если furthest) к исполняющему скрипт.</p>

<h4 id="Символьный-подтип">Символьный подтип</h4>

<p>Об этом много не расскажешь, всё его использование крутится вокруг функций <code class="highlighter-rouge">chr</code> и <code class="highlighter-rouge">ord</code>. Делают они взаимно обратные вещи: <code class="highlighter-rouge">ord</code> делает из символа его код, а <code class="highlighter-rouge">chr</code> обратно — выдаёт код символа.</p>

<p>Зачем это нужно практически - вопрос неоднозначный. Как правило, код символа удобно применять с различными свойствами кодировки. К примеру, цифры обычно перечисляются подряд: <code class="highlighter-rouge">0123456789</code>. Вот это выражение всегда истинно: <code class="highlighter-rouge">ord("7") == (ord("0") + 7)</code>. А латиница организована в два больших блока - 26 подряд идущих строчных букв, и 26 подряд идущих заглавных. И не только она - все национальные алфавиты стараются организовывать так же. Русский - не исключение (единственное, что там проблемы с буквой Ё).</p>

<p>В GML пользы от подобных приёмов мало, поскольку под самые частые задачи, где они нужны, в GML уже есть функции. К примеру, этот приём позволяет достаточно быстро собирать из известного числа строчку (что в GML делает функция <code class="highlighter-rouge">string</code>).</p>

<p>Некоторые используют <code class="highlighter-rouge">chr</code>, чтобы определять прямо в коде символы, не имеющие толкового визуального представления. К примеру, перевод строки или “нуль-символ” (<a href="http://ru.wikipedia.org/wiki/%D0%9D%D1%83%D0%BB%D1%8C-%D1%82%D0%B5%D1%80%D0%BC%D0%B8%D0%BD%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%BD%D0%B0%D1%8F_%D1%81%D1%82%D1%80%D0%BE%D0%BA%D0%B0">подробнее тут, откроется в новой вкладке</a>).</p>

<p>Можно выделить и больше подтипов, но ничего принципиально нового вырвать из них не удастся.</p>

<h3 id="Массивы">Массивы</h3>

<p>Та самая причина, по которой я рекомендую избегать цифр в названиях ваших переменных. Потому что если вам понадобилось их нумеровать - вам нужны массивы, а не отдельные переменные.</p>

<p>Можно подумать, что массивы - это просто группа переменных. Так и есть. В этом случае вы должны придумать название только группы, а каждый элемент группы можно достать по названию и номеру (которых в массивах называют индексом): <code class="highlighter-rouge">my_array[2]</code> - третий элемент массива <code class="highlighter-rouge">my_array</code> (здесь нет опечатки, он правда третий: после <code class="highlighter-rouge">0</code> и <code class="highlighter-rouge">1</code>). У номера есть ограничения: он должен быть числом, целым и неотрицательным. Говоря проще: любым из <code class="highlighter-rouge">0</code>, <code class="highlighter-rouge">1</code>, <code class="highlighter-rouge">2</code> и так далее.</p>

<p>Забавно то, что название группы массива также можно считать и названием переменной. <code class="highlighter-rouge">my_array</code> всегда равно <code class="highlighter-rouge">my_array[0]</code>, просто потому что это одно и то же. Это к нам пришло из тех традиций, где массив - просто адрес в памяти и известный размер элемента. По этим данным можно вычислить местонахождение любого элемента массива, а если взять просто адрес, без изменений, получим самый первый его элемент с индексом 0. Это по сей день живо и активно используется в “быстрых” языках, вроде С и С++.</p>

<p>Для чего это надо - для хранения некоторого ряда однотипных данных. Раз уж мы говорим о языке для создания игр, пример будет из игр. Инвентарь. Вспомним также об индексном подтипе, и будем считать, что в массиве хранятся индексы спрайтов тех предметов, что там лежат. В самых простых инвентарях это рационально.</p>

<p>Массивы делают код удобнее. Мы можем взять и нарисовать спрайт предмета, просто зная его номер. Скажем, если это 3, выйдет что-то такое: <code class="highlighter-rouge">draw_sprite(inventory[3], -1, mouse_x, mouse_y);</code>. Но вместо 3 может быть и переменная: <code class="highlighter-rouge">draw_sprite(inventory[selected_slot], -1, mouse_x, mouse_y);</code>, и переменную можно изменять. Уже сейчас вы можете сделать переключатель слотов инвентаря. А после урока с языковыми конструкциями сможете его ещё быстро и целиком рисовать.</p>

<h3 id="Эксперимент-iii">Эксперимент III</h3>

<p>Сделайте звезду, которая при создании делает 3 планеты, крутящихся по кругу вокруг неё. Причём индекс каждой планеты должен быть записан в некотором массиве - на 0 самая близкая к звезде, на 2 самая дальняя.</p>

<p>Сделайте кружок (<code class="highlighter-rouge">draw_circle</code>), который обводит одну из планет, и клавишу, с помощью которой можно переключать обведённую планету на ту, что дальше (а если самая дальняя - то снова на самую близкую). Здесь воспользуйтесь приёмом: изменяйте индекс выбранной планеты вот так: <code class="highlighter-rouge">sel_planet = (sel_planet + 1) mod 3;</code>. Этот хитрый кусочек кода никогда не даст <code class="highlighter-rouge">sel_planet</code> уйти из множества значений 0, 1 и 2. <code class="highlighter-rouge">mod</code> - это взятие остатка от деления.</p>

<p>К примеру, <code class="highlighter-rouge">49/5</code> - это, строго говоря, <code class="highlighter-rouge">9.8</code>, а вот <code class="highlighter-rouge">49 div 5</code> - это <code class="highlighter-rouge">9</code>, 5*9 = 49 - 4, и значит, остаток от деления 49 на 5 - это 4. В коде - <code class="highlighter-rouge">49 mod 5 == 4</code>.</p>

<p>К сожалению, с текущими навыками вам может быть нужно подублировать код, а не обрабатывать его циклами. Но если умеете - делайте циклами. Кто я такой, чтобы вам что-то запрещать?</p>

<p>Я считаю, что вы чему-то учитесь в процессе прохождения этих уроков, поэтому формулировки будут становиться более свободными. Под конец практики вовсе не будет, поскольку новым навыкам вы сможете найти применение почти в любой своей игре. Я не буду вас отвлекать от ваших идей своими странными упражнениями - вы вполне сможете придумывать их сами.</p>

<p>Следующий урок - очень важная ступень, отделяющая вас от просторов мира скриптов. Поэтому на написание следующего урока я потрачу побольше времени. Но я надеюсь, что я оставил достаточно пищи для размышления, чтобы вы не скучали. Можете попридумывать собственные подтипы, например. Поставить на них строгие ограничения и придумать способы применения. Если надумали что-то забавное - буду рад увидеть идеи в комментариях. Может, что-то мне настолько понравится, что я внесу это в основной текст <code class="highlighter-rouge">:)</code></p>

</div>



  

<script type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', '']);
  _gaq.push(['_trackPageview']);
  (function() {
  var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
  ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
  var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();
</script>

  </div><!-- /.main -->
</body>
</html>