<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
<title>Igor-slacker blog
</title>
<meta name="description" content="Igor-slacker blog
">
<meta name="keywords" content="GameMaker, GLSL">

<meta property="og:type" content="article">
<meta property="og:title" content="GameMaker Studio: шейдеры, введение &#8211; ">
<meta property="og:description" content="Igor-slacker blog
">
<meta property="og:url" content="http://localhost:4000/2013/07/03/gms-shaders-intro.html">
<meta property="og:site_name" content="">

<!-- Webmaster Tools verfication -->




<link rel="canonical" href="http://localhost:4000/2013/07/03/gms-shaders-intro.html">
<link href="http://localhost:4000/feed.xml" type="application/atom+xml" rel="alternate" title=" Feed">

<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />

<link rel="stylesheet" href=" /css/main.min.css" type="text/css" />
</head>
<body>
  <div class="header-container">
  <header>
      <ul class="nav">
        <!--Change the  URL here if working on an absolute domain-->
        <li><a href="http://localhost:4000"><span class="mega-octicon octicon-terminal" style="margin-right: 6px;"></span>Home</a></li>
        <li><a href="http://localhost:4000/about"><span class="mega-octicon octicon-person" style="margin-right: 6px;"></span>About</a></li>
      </ul>
  </header>
</div>

  <div class="container">
  <h2>GameMaker Studio: шейдеры, введение</h2>
<p class="meta">03 Jul 2013</p>

<div class="post">
<p>Я, как оказалось, лишил абзацев немалую часть сайта. Немножко я уже восстановил, остальным займусь позже. Сейчас — интересная тема для большинства проголосовавших (включая меня, но даже если не считать, этот вариант набрал свои голоса быстрее) в последнем голосовании. Вот они, неудобства небольшого количества людей — проголосовав ради результатов, здорово их портишь.</p>

<p>Итак, шейдеры. Их релиз обещан в GameMaker Studio 1.2, но уже сейчас можно <a href="http://store.yoyogames.com/downloads/gm-studio/GMStudio-Installer-1.1.1058.exe">скачать бету 1.1.1058</a> и попробовать их в деле. Но прежде чем пробовать, нужно понять, что это вообще такое, у многих проблемы уже с этим.</p>

<p>Для начала — разрыв шаблона для многих. Когда смотрите на видеокарту, в первую очередь смотреть нужно вовсе не на объём памяти, а на модель графического чипа. Так вышло, что я почти всё время пользуюсь видеокартами nVidia: GeForce 7600 GT, GeForce 8600M GT, GeForce GT540M. Как правило — чем число больше, тем чип сильнее, за исключением смены модельных обозначений (что в моём примере произошло перед GT540M). Чем же он сильнее? Сейчас и узнаем.</p>

<p>Вспомним немного о “больших играх”. Только ленивый не заметил, что они заставляют быстро устаревать вовсе не процессоры, а видеокарты. Но видеокарты существенно отличаются не из-за объёма памяти — а чего тогда? Напрашивается вывод — они участвуют в непосредственном расчёте картинки и имеют некие вычислительные мощности. На это же указывает факт, что памяти на видеокарте много, явно больше, чем нужно просто для передачи картинки на экран. Кстати, тут неплохо бы привести цифры. Будем считать, что каждый пиксель занимает 4 байта:</p>

<p>\( 1920 \cdot 1080 \cdot 4 = 8294400 \)</p>

<p>Каких-то 8 с лишним мегабайт. Зачем же их сотни?</p>

<p>Началось всё с <em>3dfx</em>, которые когда-то выпускали видеокарточки, ускоряющие 3D-графику. С тех пор за видеокартами закрепилось это назначение. В 3D картинки традиционно выполняют не в виде отдельных точек (что мало какая память выдержит), а в виде описаний контуров фигур. Грани, рёбра, вершины. И видеокарты принимают на себя обязанность перевести набор граней и рёбер в пиксельную картинку с учётом текстур, цветов и множества других факторов.</p>

<p>Сейчас всякая уважающая себя видеокарточка гонит внутри себя целый конвейер по отрисовке кадров для вашей игры. А частью этого конвейера являются <strong>шейдеры — программы, которые выполняет видеокарта</strong>. Состоит он из следующих этапов:</p>

<ol>
  <li><strong>Обработка переданных вершин</strong> — обычно, здесь вычисляется освещение 3D-сцены. Свет (в простейшем случае) виден лишь на поверхностях, поэтому разумно исследовать только то, на чём поверхности базируются. А каждому полигону поверхности необходимо три точки-вершины. Здесь работает вершинный шейдер, который позволяет эту стадию запрограммировать самостоятельно — скажем, переместить вершины по определённому закону в другие места (если это поверхность воды, то добавить волны, например).</li>
  <li><strong>Обрезка</strong> — незачем рисовать то, что на экран всё равно не влезает. На этой стадии все элементы сцены, не участвующие в отрисовке, исключаются из обрабатываемого материала.</li>
  <li><strong>Проекция</strong> — всякая весёлая математика, касающаяся вида проекции — перспективная проекция, или прямая (она же ортогональная). Мы сейчас будем иметь дело с прямой, в 3D обычно используется перспектива.</li>
  <li><strong>Растеризация</strong> — преобразование получившейся сцены в точки (фрагменты), согласно разрешению картинки.</li>
  <li><strong>Раскрашивание</strong> — момент, когда фрагменты становятся пикселями. Тут есть варианты. Пиксель либо приобретает цвет находившихся рядом поверхностей, либо получает его из текстуры, либо (самое интересное) из фрагментного шейдера. После этого этапа фрагменты становятся полноправными пикселями и отправляются на экран.</li>
</ol>

<p>То есть, шейдер — это некая программа, которую выполняет видеокарта. Почему её нельзя выполнять на центральном процессоре? Ответ прост — он для таких вещей не приспособлен. Стандартный вывод графики подразумевает выполнение одних и тех же (не самых простых) действий для каждой вершины и точки. Вершин может быть много, пикселей тоже.</p>

<p>Целясь в пиксели — уже отметили, что пикселей на FullHD-экране больше двух миллионов, и процессору необходимо выполнить процедуру для каждого. Многовато. Центральный процессор моего ноутбука за секунду секунду делает \( 2.1 \cdot 10^{9} \) тактов. Пусть у нас 60 кадров в секунду — получается 35 миллионов тактов на кадр. То есть, на каждый пиксель приходятся считанные такты, чуть больше десятка. И это не считая того, что есть ещё и механика игры, ОС, и много чего ещё. Мораль — не надо считать такие вещи на ЦП.</p>

<p>Поэтому сейчас чаще говорят не “видеокарта”, а “GPU”. И, в некотором смысле, его противопоставляют CPU — центральному процессору. ЦП обычно состоит из нескольких мощных ядер. GPU же состоит из множества “графических ядер”. Для сравнения: в моём компьютере ЦП состоит из двух ядер (Core i3-2310M), а ГП содержит 96 ядер (GeForce GT540M). Но при таком количестве ядер возникают сложности, с которыми проще бороться с помощью запретов, чем усложнять аппаратуру.</p>

<p>Один из таких запретов — не надо (по возможности) пользоваться циклами и if’ами, потому что графическое ядро плохо умеет перескакивать из одного места программы в другое. В университете я столкнулся с программой, которая считала минимум двух чисел без скачков — сначала записывалось одно число, затем в случае минимальности другого (что сделано без скачков, хитрым математическим трюком), оно записывалось поверх. Если кому-то интересно — <a href="http://graphics.stanford.edu/~seander/bithacks.html#IntegerMinOrMax">вот статья с кучей подобных трюков (она на английском, если что)</a>.</p>

<p>Другой нюанс программирования на GPU — разные процессы с одним и тем же шейдером никак не должны зависеть друг от друга. Это связано с тем, что выполняются они параллельно. Скажем, если вы делаете волну на воде — вы можете построить программу так, чтобы из точки на “спокойной поверхности воды” и каких-то неменяющихся (в текущем кадре) данных из игры (момент времени?) получалась точка воды в том же месте (если смотреть сверху), но на высоте, учитывающей бегущую по воде волну. Один из вариантов.</p>

<p>Теперь к практике. В GameMaker добавлен новый вид ресурса — шейдер. На вид — очень напоминает скрипт, но состоит из двух частей — вершинный и фрагментный. Должны быть оба. Если один из них ничего не должен делать, то нужно написать особый “пропускающий” шейдер, который делает то же, что происходит “по умолчанию”. Их я и разберу. Далее я буду работать с языком GLSL ES, максимально совместимым со всеми платформами, куда GameMaker Studio умеет экспортировать. Он сильно отличается от GML, <a href="http://www.khronos.org/registry/gles/specs/2.0/GLSL_ES_Specification_1.0.17.pdf">вот документация по нему</a>, я разберу основы его синтаксиса на примерах. Замечу, что если вы уже читали мои уроки про GML и/или знаете, какого стиля в нём и придерживаюсь — то найдёте много общего.</p>

<p>Итак, поехали. Пропускающий вершинный шейдер, для каждой вершины вот что он сделает:</p>

<figure class="highlight"><pre><code class="language-glsl" data-lang="glsl"><span class="c1">//Наверху "входные данные" шейдера, или аргументы.
//vecN &amp;mdash; это N-компонентный вектор. В GLSL есть vec2, vec3 и vec4. Больше никаких.
//Те, что обозначены attribute, подаются из GM автоматически
</span><span class="k">attribute</span> <span class="kt">vec3</span> <span class="n">in_Position</span><span class="p">;</span>                  <span class="c1">// Координаты вершины
</span><span class="cm">/*x, y, z*/</span>
<span class="k">attribute</span> <span class="kt">vec4</span> <span class="n">in_Colour</span><span class="p">;</span>                    <span class="c1">// Цвет вершины:
</span><span class="cm">/*красный, зелёный, синий, прозрачность*/</span>
<span class="k">attribute</span> <span class="kt">vec2</span> <span class="n">in_TextureCoord</span><span class="p">;</span>              <span class="c1">// Текстурные координаты
</span><span class="cm">/*u и v, это применяется для натягивания текстуры на фигуры*/</span>
<span class="c1">//attribute vec3 in_Normal;                  // Это тоже подаётся, но мы это не используем
</span>
<span class="c1">//Это то, что шейдер вычислит &amp;mdash; новые текстурные координаты (2D) и её цвет (RGBA, как выше)
</span><span class="k">varying</span> <span class="kt">vec2</span> <span class="n">v_vTexcoord</span><span class="p">;</span>
<span class="k">varying</span> <span class="kt">vec4</span> <span class="n">v_vColour</span><span class="p">;</span>
<span class="c1">//При этом шейдер обязательно должен вычислить значение положения вершины: gl_position
</span>
<span class="kt">void</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="c1">//В математике принято для преобразований использовать матрицы 4х4.
</span>    <span class="c1">//Не просто так, но объяснять это сейчас не нужно.
</span>    <span class="c1">//Но нужно добавить к вектору положения четвёртую координату-единицу.
</span>    <span class="kt">vec4</span> <span class="n">object_space_pos</span> <span class="o">=</span> <span class="kt">vec4</span><span class="p">(</span> <span class="n">in_Position</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="n">in_Position</span><span class="p">.</span><span class="n">y</span><span class="p">,</span> <span class="n">in_Position</span><span class="p">.</span><span class="n">z</span><span class="p">,</span> <span class="mi">1</span><span class="p">.</span><span class="mi">0</span><span class="p">);</span>

    <span class="c1">//Матрицы в линейной алгебре используются для преобразования фигур:
</span>    <span class="c1">//разнообразных поворотов, смещений, растяжений.
</span>    <span class="c1">//И применить это преобразование возможно с помощью умножения матрицы на вектор.
</span>    <span class="c1">//Матрица 4х4, вектор 4х1 (4 в высоту). Умножать матрицу 4х4 на вектор 3х1 невозможно.
</span>    <span class="c1">//Кстати, сомножители нельзя менять местами &amp;mdash; мы работаем не с числами!
</span>    <span class="c1">//Результат запишется в системную переменную gl_Position (см. выше)
</span>    <span class="c1">//Массив gm_Matrices поставляется из GM. Матрица MATRIX_WORLD_VIEW_PROJECTION
</span>    <span class="c1">//преобразует координаты так, чтобы точка попала в нужное положение, согласно
</span>    <span class="c1">//настройкам вида (координаты, наклон).
</span>    <span class="nb">gl_Position</span> <span class="o">=</span> <span class="n">gm_Matrices</span><span class="p">[</span><span class="n">MATRIX_WORLD_VIEW_PROJECTION</span><span class="p">]</span> <span class="o">*</span> <span class="n">object_space_pos</span><span class="p">;</span>
    
    <span class="c1">//Поскольку это ленивый шейдер, он ничего с цветом и координатами не делает.
</span>    <span class="c1">//Просто сразу пишет в результат, и всё.
</span>    <span class="n">v_vColour</span> <span class="o">=</span> <span class="n">in_Colour</span><span class="p">;</span>
    <span class="n">v_vTexcoord</span> <span class="o">=</span> <span class="n">in_TextureCoord</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure>

<p>Вот этот шейдер будет нашим верным помощником в течение очень долгого времени. Понимать, как он работает, полезно, но необязательно. Пользоваться им, как заклинанием, не возбраняется, потому что самое веселье мы будем творить (поначалу) во фрагментных шейдерах. Ну и раз уж начали, разберём пропускающий фрагментный шейдер. Помним — он выполнится по одному разу для каждого пикселя.</p>

<figure class="highlight"><pre><code class="language-glsl" data-lang="glsl"><span class="c1">//На вход пришли текстурные координаты и цвет вершины
</span><span class="k">varying</span> <span class="kt">vec2</span> <span class="n">v_vTexcoord</span><span class="p">;</span>
<span class="k">varying</span> <span class="kt">vec4</span> <span class="n">v_vColour</span><span class="p">;</span>

<span class="kt">void</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="c1">//Мы должны выдать пикселю цвет.
</span>    <span class="c1">//Умножение вектора на вектор в GLSL работает "почленно": получается
</span>    <span class="c1">//вектор с умноженными (первый.r * второй.r; первый.g * второй.g; ...)
</span>    <span class="c1">//texture2D возвращает цвет пикселя, который мы рисуем с текстуры (в которой
</span>    <span class="c1">//записан наш спрайт или иная форма) в указанной на ней точке.
</span>    <span class="nb">gl_FragColor</span> <span class="o">=</span> <span class="n">v_vColour</span> <span class="o">*</span> <span class="n">texture2D</span><span class="p">(</span> <span class="n">gm_BaseTexture</span><span class="p">,</span> <span class="n">v_vTexcoord</span> <span class="p">);</span>
<span class="p">}</span></code></pre></figure>

<p>Отмечу, кстати, что в OpenGL интенсивность цвета кодируется не от 0 до 255 (только целые), а от 0 до 1 (любые). Это одна из причин, по которой какой <code class="highlighter-rouge">image_blend</code> в объект не запиши, светлее оригинала он стать не сможет. Любое неотрицательное число, умноженное на число меньшее 1, не может стать больше.</p>

<p>Немножко об операции <code class="highlighter-rouge">.</code>. В GLSL, как в C, есть составные типы. В случае с GM их можно сравнить с объектами, в которых есть только фиксированный набор переменных. В vec4 есть 4 переменных. Но интересно то, что обращаться к ним можно, используя разные имена. В соответствующем порядке: <code class="highlighter-rouge">r</code>, <code class="highlighter-rouge">g</code>, <code class="highlighter-rouge">b</code>, <code class="highlighter-rouge">a</code> (типично для цвета); <code class="highlighter-rouge">x</code>, <code class="highlighter-rouge">y</code>, <code class="highlighter-rouge">z</code>, <code class="highlighter-rouge">w</code> (типично для положения); <code class="highlighter-rouge">s</code>, <code class="highlighter-rouge">t</code>, <code class="highlighter-rouge">p</code>, <code class="highlighter-rouge">q</code> (типично для текстурных координат). Использовать можно любые, порядковый номер названия у которого не больше размера вектора. Скажем, использование <code class="highlighter-rouge">w</code> у <code class="highlighter-rouge">vec3</code> закончится ошибкой.</p>

<p>Если мы возьмём этот шейдер, создадим объект со спрайтом, а в рисовании объекта напишем вот это:</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="k">if</span><span class="p">(</span> <span class="n">shader_is_compiled</span><span class="p">(</span> <span class="err">вон</span><span class="n">_</span><span class="err">тот</span><span class="n">_</span><span class="err">шейдер</span> <span class="p">)</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="n">shader_set</span><span class="p">(</span><span class="err">вон</span><span class="n">_</span><span class="err">тот</span><span class="n">_</span><span class="err">шейдер</span><span class="p">);</span>
    <span class="n">draw_self</span><span class="p">();</span>
    <span class="n">shader_reset</span><span class="p">();</span>
<span class="p">}</span>
<span class="k">else</span>
<span class="p">{</span>
    <span class="n">draw_text</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">40</span><span class="p">,</span><span class="s">"Шейдер не скомпилировался."</span><span class="p">);</span>
<span class="p">}</span></code></pre></figure>

<p>То получим… да то же самое, как если бы этого события вообще не было, или был просто <code class="highlighter-rouge">draw_self();</code>. Но самое веселье начинается уже здесь. Поскольку материала и так получилось немало, я разберу всего один шейдер из демки, остальные в следующем посте. Там будет новая механика — передача в шейдер собственных чисел. Итак…</p>

<figure class="highlight"><pre><code class="language-glsl" data-lang="glsl"><span class="c1">//Шейдер фрагментный - получили текстурные координаты и цвет из вершин
</span><span class="k">varying</span> <span class="kt">vec2</span> <span class="n">v_vTexcoord</span><span class="p">;</span>
<span class="k">varying</span> <span class="kt">vec4</span> <span class="n">v_vColour</span><span class="p">;</span>

<span class="kt">void</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="c1">//Мы это уже видели, да?
</span>    <span class="nb">gl_FragColor</span> <span class="o">=</span> <span class="p">(</span><span class="n">v_vColour</span> <span class="o">*</span> <span class="n">texture2D</span><span class="p">(</span> <span class="n">gm_BaseTexture</span><span class="p">,</span> <span class="n">v_vTexcoord</span> <span class="p">));</span>
    <span class="c1">//Добавим весёлого синтаксиса GLSL! b и g &amp;mdash; два отдельных поля из вектора
</span>    <span class="c1">//цвета. Поля там называются r, g, b, a, именно в таком порядке. А вектор
</span>    <span class="c1">//bg &amp;mdash; это вектор из двух чисел, представляющих компоненты b и g
</span>    <span class="c1">//в соответствующем порядке. Синяя и зелёная компоненты.
</span>    <span class="nb">gl_FragColor</span><span class="p">.</span><span class="n">bg</span> <span class="o">=</span> <span class="kt">vec2</span><span class="p">(</span><span class="mi">0</span><span class="p">.</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">.</span><span class="mi">0</span><span class="p">);</span>
    <span class="c1">//vec2 &amp;mdash; сборка вектора из двух компонент с указанными значениями.
</span><span class="p">}</span></code></pre></figure>

<p>Догадайтесь, что он делает. В следующем посте объяснение для тех, кто не разберётся, а также разбор оставшихся четырёх фрагментных шейдеров из демо. После них — я попробую написать парочку самостоятельно. Раньше я вовсе не работал с шейдерами, так что я понятия не имею, чем это кончится.</p>

</div>



  

<script type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', '']);
  _gaq.push(['_trackPageview']);
  (function() {
  var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
  ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
  var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();
</script>

  </div><!-- /.main -->
</body>
</html>